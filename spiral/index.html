<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brushstroke Spiral Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #themeControls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        .theme-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .theme-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .theme-btn.active {
            outline: 3px solid white;
        }
    </style>
</head>

<body>
    <div id="themeControls">
        <button class="theme-btn active" data-theme="original" style="background: linear-gradient(45deg, #6b1b47, #44aa99, #ffbe0b)">Original</button>
        <button class="theme-btn" data-theme="neon" style="background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00aa)">Neon</button>
        <button class="theme-btn" data-theme="ocean" style="background: linear-gradient(45deg, #001a4d, #006699, #00ffff)">Ocean</button>
        <button class="theme-btn" data-theme="sunset" style="background: linear-gradient(45deg, #ff4400, #ff8800, #ffcc00)">Sunset</button>
        <button class="theme-btn" data-theme="forest" style="background: linear-gradient(45deg, #004d00, #00802b, #99ff99)">Forest</button>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Color themes
        const themes = {
            original: [
                '#6b1b47', // deep purple
                '#44aa99', // teal
                '#ffbe0b', // yellow
                '#ff6b6b', // coral
                '#2ec4b6'  // turquoise
            ],
            neon: [
                '#ff00ff', // magenta
                '#00ffff', // cyan
                '#ff00aa', // pink
                '#aa00ff', // purple
                '#00ff99'  // bright green
            ],
            ocean: [
                '#001a4d', // deep blue
                '#006699', // medium blue
                '#00ffff', // cyan
                '#0099cc', // light blue
                '#66ccff'  // sky blue
            ],
            sunset: [
                '#ff4400', // orange red
                '#ff8800', // orange
                '#ffcc00', // yellow
                '#ff6600', // dark orange
                '#ffaa00'  // light orange
            ],
            forest: [
                '#004d00', // dark green
                '#00802b', // forest green
                '#99ff99', // light green
                '#006600', // deep green
                '#00cc00'  // bright green
            ]
        };

        let currentTheme = 'original';
        let brushStrokes = [];
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1;
        document.body.appendChild(renderer.domElement);

        // Setup post-processing with higher values
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.5,    // bloom strength
            0.6,    // radius
            0.1     // threshold
        );
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        function createSpiralCurve(startRadius, endRadius, turns, offset, heightOffset) {
            const points = [];
            const segments = 500;
            
            for(let i = 0; i <= segments; i++) {
                const t = i / segments;
                const angle = t * Math.PI * 2 * turns + offset;
                const radius = startRadius + (endRadius - startRadius) * t;
                const x = Math.cos(angle) * radius * 1.5;
                const y = Math.sin(angle) * radius * 1.5;
                const z = heightOffset + (t - 0.5) * 3;
                points.push(new THREE.Vector3(x, y, z));
            }
            
            return new THREE.CatmullRomCurve3(points);
        }

        function createSpirals(themeColors) {
            // Clear existing spirals
            brushStrokes.forEach(stroke => scene.remove(stroke));
            brushStrokes = [];

            const palette = themeColors.map(color => 
                new THREE.Color(color).multiplyScalar(3)
            );

            const numStrokes = 30;

            for(let i = 0; i < numStrokes; i++) {
                const startRadius = Math.random() * 3;
                const endRadius = 4.5 + Math.random() * 3;
                const turns = 2.5 + Math.random() * 1.5;
                const offset = Math.random() * Math.PI * 2;
                const heightOffset = (Math.random() - 0.5) * 3;
                
                const curve = createSpiralCurve(startRadius, endRadius, turns, offset, heightOffset);
                const points = curve.getPoints(500);

                const mainGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const mainMaterial = new THREE.LineBasicMaterial({ 
                    color: palette[i % palette.length],
                    linewidth: 5,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const mainLine = new THREE.Line(mainGeometry, mainMaterial);
                
                const numOffsetLines = 16;
                const offsetAmount = 0.3;
                
                for(let j = 0; j < numOffsetLines; j++) {
                    const offsetPoints = points.map(p => {
                        const angle = (j / numOffsetLines) * Math.PI * 2;
                        return new THREE.Vector3(
                            p.x + Math.cos(angle) * offsetAmount,
                            p.y + Math.sin(angle) * offsetAmount,
                            p.z
                        );
                    });
                    
                    const offsetGeometry = new THREE.BufferGeometry().setFromPoints(offsetPoints);
                    const offsetMaterial = new THREE.LineBasicMaterial({ 
                        color: palette[i % palette.length],
                        transparent: true,
                        opacity: 0.25,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const offsetLine = new THREE.Line(offsetGeometry, offsetMaterial);
                    mainLine.add(offsetLine);

                    if (j % 2 === 0) {
                        const innerOffset = offsetAmount * 0.5;
                        const innerPoints = points.map(p => {
                            const angle = (j / numOffsetLines) * Math.PI * 2;
                            return new THREE.Vector3(
                                p.x + Math.cos(angle) * innerOffset,
                                p.y + Math.sin(angle) * innerOffset,
                                p.z
                            );
                        });
                        
                        const innerGeometry = new THREE.BufferGeometry().setFromPoints(innerPoints);
                        const innerMaterial = new THREE.LineBasicMaterial({ 
                            color: palette[i % palette.length],
                            transparent: true,
                            opacity: 0.35,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const innerLine = new THREE.Line(innerGeometry, innerMaterial);
                        mainLine.add(innerLine);
                    }
                }
                
                brushStrokes.push(mainLine);
                scene.add(mainLine);
            }
        }

        // Initial creation
        createSpirals(themes[currentTheme]);

        camera.position.z = 10;

        // Theme switching
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active button
                document.querySelector('.theme-btn.active').classList.remove('active');
                btn.classList.add('active');
                
                // Update theme
                currentTheme = btn.dataset.theme;
                createSpirals(themes[currentTheme]);
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            
            brushStrokes.forEach((stroke, index) => {
                stroke.rotation.z += 0.001 * (index % 2 ? 1 : -1);
                stroke.rotation.y += 0.005 * (index % 2 ? 1 : 1);
                stroke.rotation.x += 0.005 * (index % 2 ? 1 : 1);
            });
            
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>

</body>

</html>